function result = sbxGather(Info, Parameters)

    %SBXGATHER Gather volumetric scanning data into single planes via maximum intensity projection.
    %   result = SBXGATHER(Info, Parameters) gathers volumetric scanning data and saves it as a new .sbx and .mat files with a maximum intensity projection frame for each scanning plane.
    %
    %   Info: structure 
    %       Info structure generated by sbxInfo from corresponding .mat file.
    %
    %   Parameters: structure
    %       Optional input containing parameter specifications.
    %
    %   result: string
    %       Used by sbxAnalysis to confirm if function ran correctly or was cancelled.
    
    if ~exist('Info', 'var')
        try
            [sbxName, sbxPath] = uigetfile('.sbx', 'Please select file containing imaging data.');
        catch
            waitfor(msgbox('Error: Please select valid .sbx file.'));
            error('Please select valid .sbx file.');
        end
    
        % pull off the file extension
        sbxName = strtok(sbxName, '.');

        Info = sbxInfo([sbxPath, sbxName]);
    end
        
    if Info.volscan == 0
        waitfor(msgbox('Error: Data does not contain volumetric scans.'));
        error('Data does not contain volumetric scans.');
    end

    if isfield(Info, 'gathered') && Info.gathered
        waitfor(msgbox('Error: Data has already been gathered.'));
        error('Data has already been gathered.');
    end
    
    % set the frame offset for when actual volumetric scanning began; adjust this till the first frame corresponds to the first scan of a full scanning waveform
    if ~exist('Parameters', 'var')
        GUI = false;
        
        volumetricOffset = 0;
        
        % set sigma of Gaussian filter applied to image to smooth out pixel artefacts - 0 is no filtering
        Parameters.gaussianFilter = 0.0;
        
        % set the number of consecutive times to motion correct
        Parameters.passes = 3;
        
        % set number of (random) frames to use in generating a reference image
        Parameters.sampleSize = 500;
        
        % specify cropping in pixels: [from left, from right, from top, from bottom]
        Parameters.frameCrop = [0, 0, 0, 0];
        
        % specify upsampling factor
        Parameters.subpixelFactor = 1;
        
        Parameters.saveResults = false;
    else
        if ~isfield(Parameters, 'GUI')
            GUI = false;
        else
            GUI = Parameters.GUI;
        end
        if ~isfield(Parameters, 'volumetricOffset')
            volumetricOffset = 0;
        else
            volumetricOffset = Parameters.volumetricOffset;
        end
        if ~isfield(Parameters, 'gaussianFilter')
            Parameters.gaussianFilter = 0.0;
        end
        if ~isfield(Parameters, 'passes')
            Parameters.passes = 3;
        end
        if ~isfield(Parameters, 'sampleSize')
            Parameters.sampleSize = 500;
        end
        if ~isfield(Parameters, 'frameCrop')
            Parameters.frameCrop = [0, 0, 0, 0];
        end
        if ~isfield(Parameters, 'subpixelFactor')
            Parameters.subpixelFactor = 1;
        end
        if ~isfield(Parameters, 'saveResults')
            Parameters.saveResults = false;
        end
    end
    
    frameCrop = Parameters.frameCrop;
    
    % get the number and order of scanning planes
    if ~isempty(Info.otwave_um)
        scanningOrder = Info.otwave_um;
    else
        scanningOrder = Info.otwave;
    end
    
    nScans = length(scanningOrder);
    planes = unique(scanningOrder);
    nPlanes = length(planes);
    
    for s = 1:nScans
        for p = 1:nPlanes
            if scanningOrder(s) == planes(p)
                scanningOrder(s) = p;
                break
            end
        end
    end
    
    oldFileID = fopen([Info.Directory.folder, Info.Directory.name, '.sbx'], 'r');
    newFileID = fopen([Info.Directory.folder, Info.Directory.name, '_gathered.sbx'], 'w');
    
    info = importdata([Info.Directory.folder, Info.Directory.name, '.mat']);

    % indicate that .sbx file has been gathered and how it was done
    info.gathered = 1;
    info.framesPerPlane = zeros(1, nPlanes);
    
    % also, the size has to be updated
    info.sz = [Info.sz(1) - frameCrop(3) - frameCrop(4), Info.sz(2) - frameCrop(1) - frameCrop(2)];
    
    if GUI
        progressBar = waitbar(0, 'Gathering volumetric scans...', 'Name', [Info.Directory.name, ': sbxGather'], 'CreateCancelBtn', 'setappdata(gcbf, ''Canceling'', 1)');
        setappdata(progressBar, 'Canceling', 0);
    end
    
    for p = 1:nPlanes
        framesToAlign = [];
        
        % collect frame indices corresponding to the current scanning plane
        for i = volumetricOffset:Info.maxIndex
           if scanningOrder(mod(i, nScans) + 1) == p
               framesToAlign(end + 1) = i - volumetricOffset;
           end
        end
               
        % pass these to sbxRegister so it knows to only align these frames
        Parameters.framesToAlign = framesToAlign;
        
        [phaseDifferences, rowShifts, columnShifts, registerResult] = sbxRegister(Info, Parameters);
        
        if strcmp(registerResult, 'Canceled')
            if GUI
                setappdata(progressBar, 'Canceling', 1)
                delete(progressBar);
                result = 'Canceled';
                return
            end
        end
        
        registeredFrames = zeros(length(framesToAlign), info.sz(1), info.sz(2));
        
        for f = 1:length(framesToAlign)
            registeredFrames(f, :, :) = applyMotionCorrection(Info, f, framesToAlign, frameCrop, phaseDifferences, rowShifts, columnShifts);
        end
        
        maxProjection = uint16(squeeze(prctile(registeredFrames, 95, 1)));
            
        % reshape the data into its original, pure form
        if Info.nChannels > 1
            maxProjection = permute(intmax('uint16') - maxProjection, [1, 3, 2]);
        else
            maxProjection = permute(intmax('uint16') - maxProjection, [2, 1]);
        end

        % make sure to use the updated number of samples per frame
        maxProjection = reshape(maxProjection, [info.sz(1)*info.sz(2)*Info.nChannels, 1]);
        
        fwrite(newFileID, maxProjection, 'uint16'); 
        
        info.framesPerPlane(p) = length(framesToAlign);
        
        if GUI
            if getappdata(progressBar, 'Canceling')
                delete(progressBar);
                result = 'Canceled';
                return
            else
                waitbar(p/nPlanes, progressBar);
            end
        end
    end
     
    save([Info.Directory.folder, Info.Directory.name, '_gathered.mat'], 'info');

    fclose(oldFileID);
    fclose(newFileID);
    
    if GUI
        delete(progressBar);
    end
    
    result = 'Completed';

end

function adjustedImage = applyMotionCorrection(Info, f, framesToAlign, frameCrop, phaseDifferences, rowShifts, columnShifts)

    % framesToAlign(f) will give the true index of the frame
    frame = sbxRead(Info, framesToAlign(f));

    if any(frameCrop > 0)
        frame = frame(frameCrop(3) + 1:Info.sz(1) - frameCrop(4), frameCrop(1) + 1:Info.sz(2) - frameCrop(2));
    end
    
    phaseDifference = phaseDifferences(f);
    rowShift = rowShifts(f);
    columnShift = columnShifts(f);
    
    if phaseDifference ~= 0 || rowShift ~= 0 || columnShift ~= 0
        adjustedImage = fft2(frame);

        [numberOfRows, numberOfColumns] = size(adjustedImage);
        Nr = ifftshift(-fix(numberOfRows/2):ceil(numberOfRows/2) - 1);
        Nc = ifftshift(-fix(numberOfColumns/2):ceil(numberOfColumns/2) - 1);
        [Nc, Nr] = meshgrid(Nc, Nr);

        adjustedImage = adjustedImage.*exp(2i*pi*(-rowShift*Nr/numberOfRows - columnShift*Nc/numberOfColumns));
        adjustedImage = adjustedImage*exp(1i*phaseDifference);

        adjustedImage = abs(ifft2(adjustedImage));
        
        % adjust values just in case
        originalMinimum = double(min(frame(:)));
        originalMaximum = double(max(frame(:)));
        adjustedMinimum = min(adjustedImage(:));
        adjustedMaximum = max(adjustedImage(:));
        
        adjustedImage = uint16((adjustedImage - adjustedMinimum)/(adjustedMaximum - adjustedMinimum)*(originalMaximum - originalMinimum) + originalMinimum);
    else
        adjustedImage = frame;
    end

end