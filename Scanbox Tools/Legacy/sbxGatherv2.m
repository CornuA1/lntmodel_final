function result = sbxGather(Info, Parameters)

    %SBXGATHER Gather volumetric scanning data into single planes via maximum intensity projection.
    %   result = SBXGATHER(Info, Parameters) gathers volumetric scanning data and saves it as a new .sbx and .mat files with a maximum intensity projection frame for each scanning plane.
    %
    %   Info: structure 
    %       Info structure generated by sbxInfo from corresponding .mat file.
    %
    %   Parameters: structure
    %       Optional input containing parameter specifications.
    %
    %   result: string
    %       Used by sbxAnalysis to confirm if function ran correctly or was cancelled.
    
    if ~exist('Info', 'var')
        try
            [sbxName, sbxPath] = uigetfile('.sbx', 'Please select file containing imaging data.');
        catch
            waitfor(msgbox('Error: Please select valid .sbx file.'));
            error('Please select valid .sbx file.');
        end
    
        % pull off the file extension
        sbxName = strtok(sbxName, '.');

        Info = sbxInfo([sbxPath, sbxName]);
    end
        
    if Info.volscan == 0
        waitfor(msgbox('Error: Data does not contain volumetric scans.'));
        error('Data does not contain volumetric scans.');
    end

    if isfield(Info, 'gathered') && Info.gathered
        waitfor(msgbox('Error: Data has already been gathered.'));
        error('Data has already been gathered.');
    end
    
    % set the frame offset for when actual volumetric scanning began; adjust this till the first frame corresponds to the first scan of a full scanning waveform
    if ~exist('Parameters', 'var')
        GUI = false;
        
        volumetricOffset = 0;
        
        % set sigma of Gaussian filter applied to image to smooth out pixel artefacts - 0 is no filtering
        gaussianFilter = 0.0;
        
        % set the number of consecutive times to motion correct
        passes = 3;
        
        % set number of (random) frames to use in generating a reference image
        sampleSize = 500;
        
        % specify cropping in pixels: [from left, from right, from top, from bottom]
        frameCrop = [0, 0, 0, 0];
        
        % specify upsampling factor
        subpixelFactor = 1;
    else
        if ~isfield(Parameters, 'GUI')
            GUI = false;
        else
            GUI = Parameters.GUI;
        end
        if ~isfield(Parameters, 'volumetricOffset')
            volumetricOffset = 0;
        else
            volumetricOffset = Parameters.volumetricOffset;
        end
        if ~isfield(Parameters, 'gaussianFilter')
            gaussianFilter = 0.0;
        else
            gaussianFilter = Parameters.gaussianFilter;
        end
        if ~isfield(Parameters, 'passes')
            passes = 3;
        else
            passes = Parameters.passes;
        end
        if ~isfield(Parameters, 'sampleSize')
            sampleSize = 500;
        else
            sampleSize = Parameters.sampleSize;
        end
        if ~isfield(Parameters, 'frameCrop')
            frameCrop = [0, 0, 0, 0];
        else
            frameCrop = Parameters.frameCrop;
        end
        if ~isfield(Parameters, 'subpixelFactor')
            subpixelFactor = 1;
        else
            subpixelFactor = Parameters.subpixelFactor;
        end
    end
    
    % get the number and order of scanning planes
    if ~isempty(Info.otwave_um)
        scanningOrder = Info.otwave_um;
    else
        scanningOrder = Info.otwave;
    end
    
    nScans = length(scanningOrder);
    planes = unique(scanningOrder);
    nPlanes = length(planes);
    
    for s = 1:nScans
        for p = 1:nPlanes
            if scanningOrder(s) == planes(p)
                scanningOrder(s) = p;
                break
            end
        end
    end
    
    info = importdata([Info.Directory.folder, Info.Directory.name, '.mat']);

    % indicate that .sbx file has been gathered and how it was done
    info.gathered = 1;
    info.framesPerPlane = zeros(1, nPlanes);
    
    % also, the size has to be updated
    info.sz = [Info.sz(1) - frameCrop(3) - frameCrop(4), Info.sz(2) - frameCrop(1) - frameCrop(2)];
    
    samplesPerPlane = info.sz(1)*info.sz(2)*Info.nChannels;
    
    maxProjections = zeros(nPlanes, samplesPerPlane);
    meanImages = zeros(nPlanes, samplesPerPlane);
    
    oldFileID = fopen([Info.Directory.folder, Info.Directory.name, '.sbx'], 'r');
    newFileID = fopen([Info.Directory.folder, Info.Directory.name, '_gathered.sbx'], 'w');
    
    if GUI
        progressBar = waitbar(0, 'Gathering volumetric scans...', 'Name', [Info.Directory.name, ': sbxGather'], 'CreateCancelBtn', 'setappdata(gcbf, ''Canceling'', 1)');
        setappdata(progressBar, 'Canceling', 0);
    end
    
    for p = 1:nPlanes
        framesToGather = [];
        
        % collect frame indices corresponding to the current scanning plane
        for i = volumetricOffset:Info.maxIndex
           if scanningOrder(mod(i, nScans) + 1) == p
               framesToGather(end + 1) = i;
           end
        end
        
        if any(frameCrop > 0)
            reference = zeros(Info.sz(1) - frameCrop(3) - frameCrop(4), Info.sz(2) - frameCrop(1) - frameCrop(2));
        else
            reference = zeros(Info.sz);
        end
            
        for pass = 1:passes + 1
            indices = randperm(length(framesToGather), sampleSize);
            indices = framesToGather(indices);

            temp = zeros(sampleSize, size(reference, 1), size(reference, 2));

            % first generate the references
            for f = 1:sampleSize
                frame = sbxRead(Info, indices(f));

                if any(frameCrop > 0)
                    frame = frame(frameCrop(3) + 1:Info.sz(1) - frameCrop(4), frameCrop(1) + 1:Info.sz(2) - frameCrop(2));
                end

                if gaussianFilter > 0
                    frame = imgaussfilt(frame, gaussianFilter);
                end

                if pass > 1
                    [~, registeredFrame] = dftregistration(fft2(reference), fft2(frame), subpixelFactor);

                    registeredFrame = abs(ifft2(registeredFrame));

                    % adjust values just in case
                    originalMinimum = double(min(frame(:)));
                    originalMaximum = double(max(frame(:)));
                    registeredMinimum = min(registeredFrame(:));
                    registeredMaximum = max(registeredFrame(:));

                    frame = (registeredFrame - registeredMinimum)/(registeredMaximum - registeredMinimum)*(originalMaximum - originalMinimum) + originalMinimum;
                end

                temp(f, :, :) = frame;
                
                if GUI
                    if getappdata(progressBar, 'Canceling')
                        delete(progressBar);

                        result = 'Canceled';
                        return
                    end
                end
            end

            reference = uint16(squeeze(max(temp, [], 1)));

            % on the last pass, register each frame
            if pass == passes + 1
                if GUI
                    if getappdata(progressBar, 'Canceling')
                        delete(progressBar);

                        result = 'Canceled';
                        return
                    end
                end
                
                % after the first plane, register subsequent references to the previous reference to prevent drift
                if p > 1
                    [~, registeredReference] = dftregistration(fft2(lastReference), fft2(reference), subpixelFactor);

                    registeredReference = abs(ifft2(registeredReference));

                    % adjust values just in case
                    originalMinimum = double(min(reference(:)));
                    originalMaximum = double(max(reference(:)));
                    registeredMinimum = min(registeredReference(:));
                    registeredMaximum = max(registeredReference(:));

                    reference = (registeredReference - registeredMinimum)/(registeredMaximum - registeredMinimum)*(originalMaximum - originalMinimum) + originalMinimum;
                end

                registeredFrames = zeros(length(framesToGather), info.sz(1), info.sz(2));
                
                for f = 1:length(framesToGather)
                    frame = sbxRead(Info, framesToGather(f));

                    if any(frameCrop > 0)
                        frame = frame(frameCrop(3) + 1:Info.sz(1) - frameCrop(4), frameCrop(1) + 1:Info.sz(2) - frameCrop(2));
                    end

                    if gaussianFilter > 0
                        smoothedFrame = imgaussfilt(frame, gaussianFilter);
                    end
                    
                    [temp, ~] = dftregistration(fft2(reference), fft2(smoothedFrame), subpixelFactor);
                
                    phaseDifference = temp(2);
                    rowShift = temp(3);
                    columnShift = temp(4);

                    if phaseDifference ~= 0 || rowShift ~= 0 || columnShift ~= 0
                        registeredFrame = fft2(frame);

                        [numberOfRows, numberOfColumns] = size(registeredFrame);
                        Nr = ifftshift(-fix(numberOfRows/2):ceil(numberOfRows/2) - 1);
                        Nc = ifftshift(-fix(numberOfColumns/2):ceil(numberOfColumns/2) - 1);
                        [Nc, Nr] = meshgrid(Nc, Nr);

                        registeredFrame = registeredFrame.*exp(2i*pi*(-rowShift*Nr/numberOfRows - columnShift*Nc/numberOfColumns));
                        registeredFrame = registeredFrame*exp(1i*phaseDifference);

                        registeredFrame = abs(ifft2(registeredFrame));

                        % adjust values just in case
                        originalMinimum = double(min(frame(:)));
                        originalMaximum = double(max(frame(:)));
                        adjustedMinimum = min(registeredFrame(:));
                        adjustedMaximum = max(registeredFrame(:));

                        registeredFrame = uint16((registeredFrame - adjustedMinimum)/(adjustedMaximum - adjustedMinimum)*(originalMaximum - originalMinimum) + originalMinimum);
                    else
                        registeredFrame = frame;
                    end

                    registeredFrames(f, :, :) = registeredFrame;
                end
                    
                meanImage = uint16(squeeze(mean(registeredFrames, 1)));
                maxProjection = uint16(squeeze(prctile(registeredFrames, 95, 1)));

                % reshape the data into its original, pure form
                if Info.nChannels > 1
                    meanImage = permute(intmax('uint16') - meanImage, [1, 3, 2]);
                    maxProjection = permute(intmax('uint16') - maxProjection, [1, 3, 2]);
                else
                    meanImage = permute(intmax('uint16') - meanImage, [2, 1]);
                    maxProjection = permute(intmax('uint16') - maxProjection, [2, 1]);
                end

                % make sure to use the updated number of samples per frame
                meanImages(p, :) = reshape(meanImage, [samplesPerPlane, 1]);
                maxProjections(p, :) = reshape(maxProjection, [samplesPerPlane, 1]);

                info.framesPerPlane(p) = length(framesToGather);
                
                lastReference = reference;
                
                if GUI
                    if getappdata(progressBar, 'Canceling')
                        delete(progressBar);

                        result = 'Canceled';
                        return
                    else
                        waitbar(p/nPlanes, progressBar);
                    end
                end
            end
        end
    end
    
    for p = 1:nPlanes
        fwrite(newFileID, uint16(meanImages(p, :).'), 'uint16');
    end
    
    for p = 1:nPlanes
        fwrite(newFileID, uint16(maxProjections(p, :).'), 'uint16');
    end
    
    save([Info.Directory.folder, Info.Directory.name, '_gathered.mat'], 'info');

    fclose(oldFileID);
    fclose(newFileID);
    
    if GUI
        delete(progressBar);
    end
    
    result = 'Completed';

end